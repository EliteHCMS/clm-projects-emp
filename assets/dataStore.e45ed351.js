var g=Object.defineProperty,q=Object.defineProperties;var j=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var h=(e,t,s)=>t in e?g(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,f=(e,t)=>{for(var s in t||(t={}))P.call(t,s)&&h(e,s,t[s]);if(a)for(var s of a(t))R.call(t,s)&&h(e,s,t[s]);return e},m=(e,t)=>q(e,j(t));import{m as y,l as o}from"./index.54a03736.js";import{u as l,q as d}from"./quickbase.d7761f7e.js";import{localforage as u}from"./localForage.0e31c343.js";import{dayjs as c}from"./dayjs.282c293e.js";const $=y("projectDataStore",{state:()=>({selectedProject:null,inProcess:{},pending:{},deployments:{},assignments:{},projects:{},openRequest:{},pendingRequest:{},closedRequest:{},openClassifications:{},pendingClassifications:{},closedClassifications:{},nameRequest:{},requestedTimeStamps:{},trainingMatrixColumns:{},trainingMatrixInputs:{},disaReady:{}}),getters:{getInProcess:e=>t=>{if(t)return e.inProcess[t]?e.inProcess[t]:[];{let s=[];return Object.keys(e.inProcess).forEach(n=>{s=s.concat(e.inProcess[n])}),s}},getPending:e=>t=>{if(t)return e.pending[t]?e.pending[t]:[];{let s=[];return Object.keys(e.pending).forEach(n=>{s=s.concat(e.pending[n])}),s}},getDeployments:e=>t=>{if(t)return e.deployments[t]?e.deployments[t]:[];{let s=[];return Object.keys(e.deployments).forEach(n=>{s=s.concat(e.deployments[n])}),s}},getAssignments:e=>t=>{if(t)return e.assignments[t]?e.assignments[t]:[];{let s=[];return Object.keys(e.assignments).forEach(n=>{s=s.concat(e.assignments[n])}),s}},getOpenRequest:e=>t=>{if(t)return e.openRequest[t]?e.openRequest[t]:[];{let s=[];return Object.keys(e.openRequest).forEach(n=>{s=s.concat(e.openRequest[n])}),s}},getPendingRequest:e=>t=>{if(t)return e.pendingRequest[t]?e.pendingRequest[t]:[];{let s=[];return Object.keys(e.pendingRequest).forEach(n=>{s=s.concat(e.pendingRequest[n])}),s}},getClosedRequest:e=>t=>{if(t)return e.closedRequest[t]?e.closedRequest[t]:[];{let s=[];return Object.keys(e.closedRequest).forEach(n=>{s=s.concat(e.closedRequest[n])}),s}},getNameRequest:e=>t=>{if(t)return e.nameRequest[t]?e.nameRequest[t]:[];{let s=[];return Object.keys(e.nameRequest).forEach(n=>{s=s.concat(e.nameRequest[n])}),s}},getProjects:e=>(t,s)=>{if(!s&&!t){let n=[];return Object.keys(e.projects).forEach(r=>{n=n.concat(e.projects[r])}),n}else if(!s&&t){const{userProjects:n}=l();let r=[];return n(t).forEach(i=>{r=r.concat(e.projects[i[8]])}),r}else if(s&&t){const{getOffice:n}=l(),r=n(s);return t==="read"&&r&&r[39]!==!0?[]:(t==="create"||t==="update")&&r&&r[40]!==!0?[]:t==="manage"&&r&&r[41]!==!0?[]:e.projects[s]?e.projects[s]:[]}else return e.projects[s]?e.projects[s]:[]},getRequestedTimeStamps(e){return e.requestedTimeStamps},getselectedProject(e){return e.selectedProject},getMatrixColumns:e=>t=>{if(t)return e.trainingMatrixColumns[t]?e.trainingMatrixColumns[t]:[];{let s=[];return Object.keys(e.trainingMatrixColumns).forEach(n=>{s=s.concat(e.trainingMatrixColumns[n])}),s}},getMatrixInputs:e=>t=>t?e.trainingMatrixInputs[t]?e.trainingMatrixInputs[t]:[]:null,getDisaReady:e=>t=>t?e.disaReady[t]:!1},actions:{setselectedProject(e,t){this.selectedProject=e},setTimeStamp({name:e,timeStamp:t,projectId:s},n){if(this.requestedTimeStamps[s]?this.requestedTimeStamps[s][e]=t:this.requestedTimeStamps[s]={[e]:t},n){const r=JSON.parse(JSON.stringify(this.requestedTimeStamps));u.setItem(`${o.storageProcessTimeStamps}`,r)}},setTimeStampState(e){this.requestedTimeStamps=e},async fetchInProcess(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"In Processes By Project"}}];if(t.inProcess&&(t.inProcess.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"inProcess",timeStamp:c()},!0);const{data:r}=await d.fetchFromHiringApp({fields:n});return this.setInProcess({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllInProcess(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchInProcess(m(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setInProcess({projectId:e,data:t},s){this.inProcess[e]=t,s&&u.setItem(`${o.storageInProcess}_${e}`,t)},async fetchPending(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Dispatches By Project"}}];if(t.pending&&(t.pending.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pending",timeStamp:c()},!0);const{data:r}=await d.fetchFromHiringApp({fields:n});return this.setPending({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllPending(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchPending(m(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setPending({projectId:e,data:t},s){this.pending[e]=t,s&&u.setItem(`${o.storagePending}_${e}`,t)},async fetchDeployments(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Deployments By Project"}}];if(t.deployments&&(t.deployments.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"deployments",timeStamp:c()},!0);const{data:r}=await d.fetchFromHiringApp({fields:n});return this.setDeployments({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllDeployments(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchDeployments(m(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},async setDeployments({projectId:e,data:t},s){this.deployments[e]=t,s&&u.setItem(`${o.storageDeployments}_${e}`,t)},updateDeployment({projectId:e,key:t,record:s}){const n=this.deployments[e].findIndex(r=>r[3]===t);n>-1&&(this.deployments[e][n]=s)},async fetchAssignments(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Assignments By Project"}}];if(t.assignments&&(t.assignments.isBefore(c().subtract(5,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"assignments",timeStamp:c()},!0);const{data:r}=await d.fetchFromHiringApp({fields:n});return this.setAssignments({projectId:e.projectId,data:r},!0),{data:r}}else return{data:this.getAssignments(e.projectId)}},async fetchAllAssignments(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchAssignments(m(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},async setAssignments({projectId:e,data:t},s){this.assignments[e]=t,s&&u.setItem(`${o.storageAssignments}_${e}`,t)},async fetchOpenRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Open Requests By Project"}}];if(t.openRequest&&(t.openRequest.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"openRequest",timeStamp:c()},!0);const{data:r}=await d.fetchFromProjectsApp({fields:n});return this.setOpenRequest({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllOpenRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchOpenRequest(m(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setOpenRequest({projectId:e,data:t},s){this.openRequest[e]=t,s&&u.setItem(`${o.storageOpenRequest}_${e}`,t)},async fetchPendingRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Pending Requests By Project"}}];if(t.pendingRequest&&(t.pendingRequest.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pendingRequest",timeStamp:c()},!0);const{data:r}=await d.fetchFromProjectsApp({fields:n});return this.setPendingRequest({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllPendingRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchPendingRequest(m(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setPendingRequest({projectId:e,data:t},s){this.pendingRequest[e]=t,s&&u.setItem(`${o.storagePendingRequest}_${e}`,t)},async fetchClosedRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Closed Requests By Project"}}];if(t.closedRequest&&(t.closedRequest.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"closedRequest",timeStamp:c()},!0);const{data:r}=await d.fetchFromProjectsApp({fields:n});return this.setClosedRequest({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllClosedRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchClosedRequest(m(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setClosedRequest({projectId:e,data:t},s){this.closedRequest[e]=t,s&&u.setItem(`${o.storageClosedRequest}_${e}`,t)},async fetchNameRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Name Requests By Project"}}];if(t.nameRequest&&(t.nameRequest.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"nameRequest",timeStamp:c()},!0);const{data:r}=await d.fetchFromHiringApp({fields:n});return this.setNameRequest({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllNameRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchNameRequest(m(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setNameRequest({projectId:e,data:t},s){this.nameRequest[e]=t,s&&u.setItem(`${o.storageNameRequest}_${e}`,t)},async fetchProjects(e){const{getOffice:t}=l(),s=this.getRequestedTimeStamps[e.projectId]||{};let n=!0;if(e&&e.access){const i=t(e.projectId);if(e.access==="read"&&i&&i[39]!==!0)return{data:[]};if((e.access==="create"||e.access==="update")&&i&&i[40]!==!0)return{data:[]};if(e.access==="manage"&&i&&i[41]!==!0)return{data:[]}}const r=[{9:{value:e.projectId},7:{value:"Projects"}}];if(s.projects&&(s.projects.isBefore(c().subtract(1,"minute"))?n=!0:n=e.refresh?e.refresh:!1),n){this.setTimeStamp({projectId:e.projectId,name:"projects",timeStamp:c()},!0);const{data:i}=await d.fetchFromProjectsApp({fields:r});return this.setProjects({projectId:e.projectId,data:i},!0),{data:i}}else return{data:[]}},async fetchAllProjects(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchProjects(m(f({},e),{projectId:r[8]}));s.push(i)}),await Promise.allSettled(s)},setProjects({projectId:e,data:t},s){e&&t&&(this.projects[e]=t),s&&e&&u.setItem(`${o.storageProjects}_${e}`,t)},async fetchPendingProjects(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Pending Projects"}}];if(t.pendingProjects&&(t.pendingProjects.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pendingProjects",timeStamp:c()},!0);const{data:r}=await d.fetchFromProjectsApp({fields:n});return this.setPendingProjects({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllPendingProjects(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchPendingProjects(m(f({},e),{projectId:r[8]}));s.push(i)}),await Promise.allSettled(s)},setPendingProjects({projectId:e,data:t},s){this.pendingProjects[e]=t,s&&u.setItem(`${o.storagePendingProjects}_${e}`,t)},setMatrixColumns({id:e,data:t},s){e&&t&&(this.trainingMatrixColumns[e]=t),s&&e&&u.setItem(`clm_proj_matrix_columns_${e}`,t)},setMatrixInputs({id:e,data:t},s){e&&t&&(this.trainingMatrixInputs[e]=t),s&&e&&u.setItem(`clm_proj_matrix_inputs_${e}`,t)},setDisaStatus({assignmentId:e,id:t,projectId:s,data:n}){if(this.assignments[s]){const r=this.assignments[s].findIndex(i=>i[3]===e);r>-1&&(this.assignments[s][r].employee[556]=n)}},setDisaReady({id:e}){this.disaReady[e]=!0},async removeData({type:e,key:t,item:s,storageKey:n}){const r=this[e][t].findIndex(p=>p[3]===s[3]);r>-1&&this[e][t].splice(r,1);const i=this[e][t];u.removeItem(`${o[n]}_${t}`),u.getItem(`${o[n]}_${t}`)||u.setItem(`${o[n]}_${t}`,i)}}});export{$ as u};
