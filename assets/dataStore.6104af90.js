var g=Object.defineProperty,q=Object.defineProperties;var j=Object.getOwnPropertyDescriptors;var h=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var d=(e,t,s)=>t in e?g(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,f=(e,t)=>{for(var s in t||(t={}))P.call(t,s)&&d(e,s,t[s]);if(h)for(var s of h(t))R.call(t,s)&&d(e,s,t[s]);return e},a=(e,t)=>q(e,j(t));import{m as y,k as u}from"./index.226bbe9e.js";import{u as l,q as m}from"./quickbase.aae604ff.js";import{localforage as o}from"./localForage.2f4a21a3.js";import{dayjs as c}from"./dayjs.61ba8b06.js";import{u as I}from"./useQuerySaver.ae1b8d62.js";const O=y("projectDataStore",{state:()=>({selectedProject:null,inProcess:{},pending:{},deployments:{},assignments:{},releases:{},projects:{},openRequest:{},pendingRequest:{},closedRequest:{},openClassifications:{},pendingClassifications:{},closedClassifications:{},nameRequest:{},requestedTimeStamps:{},trainingMatrixColumns:{},trainingMatrixInputs:{},disaReady:{},inventory:{}}),getters:{getInProcess:e=>t=>{if(t)return e.inProcess[t]?e.inProcess[t]:[];{let s=[];return Object.keys(e.inProcess).forEach(n=>{s=s.concat(e.inProcess[n])}),s}},getPending:e=>t=>{if(t)return e.pending[t]?e.pending[t]:[];{let s=[];return Object.keys(e.pending).forEach(n=>{s=s.concat(e.pending[n])}),s}},getDeployments:e=>t=>{if(t)return e.deployments[t]?e.deployments[t]:[];{let s=[];return Object.keys(e.deployments).forEach(n=>{s=s.concat(e.deployments[n])}),s}},getAssignments:e=>t=>{if(t)return e.assignments[t]?e.assignments[t]:[];{let s=[];return Object.keys(e.assignments).forEach(n=>{s=s.concat(e.assignments[n])}),s}},getReleases:e=>t=>{if(t)return e.releases[t]?e.releases[t]:[];{let s=[];return Object.keys(e.releases).forEach(n=>{s=s.concat(e.releases[n])}),s}},getOpenRequest:e=>t=>{if(t)return e.openRequest[t]?e.openRequest[t]:[];{let s=[];return Object.keys(e.openRequest).forEach(n=>{s=s.concat(e.openRequest[n])}),s}},getPendingRequest:e=>t=>{if(t)return e.pendingRequest[t]?e.pendingRequest[t]:[];{let s=[];return Object.keys(e.pendingRequest).forEach(n=>{s=s.concat(e.pendingRequest[n])}),s}},getClosedRequest:e=>t=>{if(t)return e.closedRequest[t]?e.closedRequest[t]:[];{let s=[];return Object.keys(e.closedRequest).forEach(n=>{s=s.concat(e.closedRequest[n])}),s}},getNameRequest:e=>t=>{if(t)return e.nameRequest[t]?e.nameRequest[t]:[];{let s=[];return Object.keys(e.nameRequest).forEach(n=>{s=s.concat(e.nameRequest[n])}),s}},getProjects:e=>(t,s)=>{if(!s&&!t){let n=[];return Object.keys(e.projects).forEach(r=>{n=n.concat(e.projects[r])}),n}else if(!s&&t){const{userProjects:n}=l();let r=[];return n(t).forEach(i=>{r=r.concat(e.projects[i[8]])}),r}else if(s&&t){const{getOffice:n}=l(),r=n(s);return t==="read"&&r&&r[39]!==!0?[]:(t==="create"||t==="update")&&r&&r[40]!==!0?[]:t==="manage"&&r&&r[41]!==!0?[]:e.projects[s]?e.projects[s]:[]}else return e.projects[s]?e.projects[s]:[]},getRequestedTimeStamps(e){return e.requestedTimeStamps},getselectedProject(e){return e.selectedProject},getMatrixColumns:e=>t=>{if(t)return e.trainingMatrixColumns[t]?e.trainingMatrixColumns[t]:[];{let s=[];return Object.keys(e.trainingMatrixColumns).forEach(n=>{s=s.concat(e.trainingMatrixColumns[n])}),s}},getMatrixInputs:e=>t=>t?e.trainingMatrixInputs[t]?e.trainingMatrixInputs[t]:[]:null,getDisaReady:e=>t=>t?e.disaReady[t]:!1,getInventory:e=>t=>t?e.inventory[t]?e.inventory[t]:null:e.inventory,getInventoryItems:e=>t=>t?e.inventory[t]?e.inventory[t].items:null:"ID is required"},actions:{setselectedProject(e,t){this.selectedProject=e},setTimeStamp({name:e,timeStamp:t,projectId:s},n){if(this.requestedTimeStamps[s]?this.requestedTimeStamps[s][e]=t:this.requestedTimeStamps[s]={[e]:t},n){const r=JSON.parse(JSON.stringify(this.requestedTimeStamps));o.setItem(`${u.storageProcessTimeStamps}`,r)}},setTimeStampState(e){this.requestedTimeStamps=e},async fetchInProcess(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"In Processes By Project"}}];if(t.inProcess&&(t.inProcess.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"inProcess",timeStamp:c()},!0);const{data:r}=await m.fetchFromHiringApp({fields:n});return this.setInProcess({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllInProcess(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchInProcess(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setInProcess({projectId:e,data:t},s){this.inProcess[e]=t,s&&o.setItem(`${u.storageInProcess}_${e}`,t)},async fetchPending(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Dispatches By Project"}}];if(t.pending&&(t.pending.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pending",timeStamp:c()},!0);const{data:r}=await m.fetchFromHiringApp({fields:n});return this.setPending({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllPending(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchPending(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setPending({projectId:e,data:t},s){this.pending[e]=t,s&&o.setItem(`${u.storagePending}_${e}`,t)},async fetchDeployments(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Deployments By Project"}}];if(t.deployments&&(t.deployments.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"deployments",timeStamp:c()},!0);const{data:r}=await m.fetchFromHiringApp({fields:n});return this.setDeployments({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllDeployments(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchDeployments(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},async setDeployments({projectId:e,data:t},s){this.deployments[e]=t,s&&o.setItem(`${u.storageDeployments}_${e}`,t)},updateDeployment({projectId:e,key:t,record:s}){const n=this.deployments[e].findIndex(r=>r[3]===t);n>-1&&(this.deployments[e][n]=s)},async fetchAssignments(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Assignments By Project"}}];if(t.assignments&&(t.assignments.isBefore(c().subtract(5,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"assignments",timeStamp:c()},!0);const{data:r}=await m.fetchFromHiringApp({fields:n});return this.setAssignments({projectId:e.projectId,data:r},!0),{data:r}}else return{data:this.getAssignments(e.projectId)}},async fetchAllAssignments(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchAssignments(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},async setAssignments({projectId:e,data:t},s){this.assignments[e]=t,s&&o.setItem(`${u.storageAssignments}_${e}`,t)},async fetchReleases(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[I({type:"releases",query:`{'41'.EX.'${e.projectId}'}AND{'42'.XEX.'Complete'}AND({'36'.OAF.'today'}OR{'36'.IR.'last 30 d'}OR{'1'.IR.'last 30 d'})`})];if(t.releases&&(t.releases.isBefore(c().subtract(5,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"releases",timeStamp:c()},!0);const{data:r}=await m.fetchFromHiringApp({fields:n});return this.setReleases({projectId:e.projectId,data:r},!0),{data:r}}else return{data:this.getReleases(e.projectId)}},async fetchAllReleases(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchReleases(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setReleases({projectId:e,data:t}){this.releases[e]=t},async fetchOpenRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Open Requests By Project"}}];if(t.openRequest&&(t.openRequest.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"openRequest",timeStamp:c()},!0);const{data:r}=await m.fetchFromProjectsApp({fields:n});return this.setOpenRequest({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllOpenRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchOpenRequest(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setOpenRequest({projectId:e,data:t},s){this.openRequest[e]=t,s&&o.setItem(`${u.storageOpenRequest}_${e}`,t)},async fetchPendingRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Pending Requests By Project"}}];if(t.pendingRequest&&(t.pendingRequest.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pendingRequest",timeStamp:c()},!0);const{data:r}=await m.fetchFromProjectsApp({fields:n});return this.setPendingRequest({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllPendingRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchPendingRequest(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setPendingRequest({projectId:e,data:t},s){this.pendingRequest[e]=t,s&&o.setItem(`${u.storagePendingRequest}_${e}`,t)},async fetchClosedRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Closed Requests By Project"}}];if(t.closedRequest&&(t.closedRequest.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"closedRequest",timeStamp:c()},!0);const{data:r}=await m.fetchFromProjectsApp({fields:n});return this.setClosedRequest({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllClosedRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchClosedRequest(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setClosedRequest({projectId:e,data:t},s){this.closedRequest[e]=t,s&&o.setItem(`${u.storageClosedRequest}_${e}`,t)},async fetchNameRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Name Requests By Project"}}];if(t.nameRequest&&(t.nameRequest.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"nameRequest",timeStamp:c()},!0);const{data:r}=await m.fetchFromHiringApp({fields:n});return this.setNameRequest({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllNameRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchNameRequest(a(f({},e),{projectId:r[9]}));s.push(i)}),await Promise.allSettled(s)},setNameRequest({projectId:e,data:t},s){this.nameRequest[e]=t,s&&o.setItem(`${u.storageNameRequest}_${e}`,t)},async fetchProjects(e){const{getOffice:t}=l(),s=this.getRequestedTimeStamps[e.projectId]||{};let n=!0;if(e&&e.access){const i=t(e.projectId);if(e.access==="read"&&i&&i[39]!==!0)return{data:[]};if((e.access==="create"||e.access==="update")&&i&&i[40]!==!0)return{data:[]};if(e.access==="manage"&&i&&i[41]!==!0)return{data:[]}}const r=[{9:{value:e.projectId},7:{value:"Projects"}}];if(s.projects&&(s.projects.isBefore(c().subtract(1,"minute"))?n=!0:n=e.refresh?e.refresh:!1),n){this.setTimeStamp({projectId:e.projectId,name:"projects",timeStamp:c()},!0);const{data:i}=await m.fetchFromProjectsApp({fields:r});return this.setProjects({projectId:e.projectId,data:i},!0),{data:i}}else return{data:[]}},async fetchAllProjects(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchProjects(a(f({},e),{projectId:r[8]}));s.push(i)}),await Promise.allSettled(s)},setProjects({projectId:e,data:t},s){e&&t&&(this.projects[e]=t),s&&e&&o.setItem(`${u.storageProjects}_${e}`,t)},async fetchPendingProjects(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const n=[{9:{value:e.projectId},7:{value:"Pending Projects"}}];if(t.pendingProjects&&(t.pendingProjects.isBefore(c().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pendingProjects",timeStamp:c()},!0);const{data:r}=await m.fetchFromProjectsApp({fields:n});return this.setPendingProjects({projectId:e.projectId,data:r},!0),{data:r}}else return{data:[]}},async fetchAllPendingProjects(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(r=>{let i=this.fetchPendingProjects(a(f({},e),{projectId:r[8]}));s.push(i)}),await Promise.allSettled(s)},setPendingProjects({projectId:e,data:t},s){this.pendingProjects[e]=t,s&&o.setItem(`${u.storagePendingProjects}_${e}`,t)},setMatrixColumns({id:e,data:t},s){e&&t&&(this.trainingMatrixColumns[e]=t),s&&e&&o.setItem(`clm_proj_matrix_columns_${e}`,t)},setMatrixInputs({id:e,data:t},s){e&&t&&(this.trainingMatrixInputs[e]=t),s&&e&&o.setItem(`clm_proj_matrix_inputs_${e}`,t)},setDisaStatus({assignmentId:e,id:t,projectId:s,data:n}){if(this.assignments[s]){const r=this.assignments[s].findIndex(i=>i[3]===e);r>-1&&(this.assignments[s][r].employee[556]=n)}},setDisaReady({id:e}){this.disaReady[e]=!0},setInventory({id:e,data:t}){this.inventory[e]=t},updateInventoryItems({id:e,data:t}){this.inventory[e]?this.inventory[e].items=t:this.inventory[e]={3:e,items:t}},async removeData({type:e,key:t,item:s,storageKey:n}){const r=this[e][t],i=r?this[e][t].findIndex(p=>p[3]===s[3]):-1;i>-1&&this[e][t].splice(i,1),o.removeItem(`${u[n]}_${t}`),r&&!o.getItem(`${u[n]}_${t}`)&&o.setItem(`${u[n]}_${t}`,r)}}});export{O as u};
